<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>arapaima.uk </title>
    <link>http://arapaima.uk/tags/vsts/</link>
    <language>en-us</language>
    <author>Gavin Campbell</author>
    <rights>(C) 2018</rights>
    <updated>2018-03-17 00:00:00 &#43;0000 UTC</updated>

    
      
        <item>
          <title>Building an SSDT project with YAML build in VSTS</title>
          <link>http://arapaima.uk/post/2018-03-17-building-ssdt-project-vsts-yaml/</link>
          <pubDate>Sat, 17 Mar 2018 00:00:00 UTC</pubDate>
          <author>Gavin Campbell</author>
          <guid>http://arapaima.uk/post/2018-03-17-building-ssdt-project-vsts-yaml/</guid>
          <description>

&lt;p&gt;It may have been a while coming, at least compared to &lt;a href=&#34;https://jenkins.io/solutions/pipeline/&#34;&gt;Jenkins Pipeline&lt;/a&gt;, &lt;a href=&#34;https://travis-ci.org/&#34;&gt;Travis-CI&lt;/a&gt;, and friends, but VSTS now offers the facility to specify your build pipeline as YAML, meaning it can be version controlled with your application code. YAML Release Management Pipelines are &amp;ldquo;on the way&amp;rdquo;, but not yet publically available.&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;The YAML Build is. The release is not yet.  &lt;a href=&#34;https://t.co/FCHfdfMHd7&#34;&gt;https://t.co/FCHfdfMHd7&lt;/a&gt;&lt;/p&gt;&amp;mdash; Donovan Brown (@DonovanBrown) &lt;a href=&#34;https://twitter.com/DonovanBrown/status/971796151862222848?ref_src=twsrc%5Etfw&#34;&gt;March 8, 2018&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;


&lt;p&gt;YAML Build Definitions are currently in public preview, so you&amp;rsquo;ll need to ensure you have the &lt;a href=&#34;https://docs.microsoft.com/en-us/vsts/collaborate/preview-features&#34;&gt;feature enabled for your account&lt;/a&gt;.&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;h2 id=&#34;the-sample-project&#34;&gt;The Sample Project&lt;/h2&gt;

&lt;p&gt;We don&amp;rsquo;t even need to download anything to get going with this, we can just use the WideWorldImporters Sample Database, which is buried in the &lt;a href=&#34;https://github.com/Microsoft/sql-server-samples&#34;&gt;SQL Server Samples repo on GitHub&lt;/a&gt;, as VSTS supports building GitHub hosted projects. If you&amp;rsquo;re following along, you&amp;rsquo;ll need to &lt;a href=&#34;https://help.github.com/articles/fork-a-repo/&#34;&gt;create your own fork&lt;/a&gt; of the official &lt;a href=&#34;https://github.com/Microsoft/sql-server-samples&#34;&gt;Microsoft/sql-server-samples&lt;/a&gt; repo, as we&amp;rsquo;ll be adding the YAML build definition to the root of our repo (yes, you need to have a &lt;a href=&#34;https://github.com/join&#34;&gt;Github Account&lt;/a&gt; for this to work). According to the &lt;a href=&#34;https://docs.microsoft.com/en-us/vsts/build-release/actions/build-yaml&#34;&gt;docs&lt;/a&gt;, the only sources currently supported for YAML Build Definitions are Git (hosted in VSTS) and GitHub, so if your code is hosted elsewhere you&amp;rsquo;ll have to wait a while longer.&lt;/p&gt;

&lt;h3 id=&#34;creating-a-dummy-build-definition&#34;&gt;Creating a dummy build definition&lt;/h3&gt;

&lt;p&gt;Just to make sure everything is working, it&amp;rsquo;s not a bad idea to go ahead and create a trivial build definition now. By convention, this file is called &lt;code&gt;.vsts-ci.yml&lt;/code&gt; and is placed at the root of the repo. You can create this directly from the GitHub UI with the &amp;ldquo;Create New File&amp;rdquo; button. &lt;a href=&#34;https://github.com/arapaima-uk/sql-server-samples/blob/fa28d3f8803991a20884722e23fe01be6f170ca4/.vsts-ci.yml&#34;&gt;Mine&lt;/a&gt; just has a single step, which is rather unimaginative:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;steps&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;-&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;script&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;echo&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;hello&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;world&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;making-sure-vsts-can-talk-to-github&#34;&gt;Making sure VSTS can talk to GitHub&lt;/h2&gt;

&lt;p&gt;The easiest way to do this, in my view at least, is to create a &lt;a href=&#34;https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/&#34;&gt;Personal Access Token&lt;/a&gt; we can use so that VSTS can authenticate to GitHub. The &lt;code&gt;public_repo&lt;/code&gt; scope will be adequate for everything we need to do here.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-eu-west-1.amazonaws.com/aksidjenakfjg/github-vsts-yaml/create-access-token-public-repo.png&#34; alt=&#34;Creating a personal access token&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You will need to copy the value of the token from GitHub as soon as you create it, it won&amp;rsquo;t be accessible again.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-eu-west-1.amazonaws.com/aksidjenakfjg/github-vsts-yaml/copy-personal-access-token.png&#34; alt=&#34;Copying the access token&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;creating-the-project-in-vsts&#34;&gt;Creating the Project in VSTS&lt;/h2&gt;

&lt;p&gt;Having selected the &amp;ldquo;New Project&amp;rdquo; button, we have a couple of forms to fill in. The first is just to give our VSTS project a name, the rest of the fields can be left at their defaults.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-eu-west-1.amazonaws.com/aksidjenakfjg/github-vsts-yaml/vst-new-project.png&#34; alt=&#34;Creating a new project in VSTS&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Next, we specify that we are building code from an external repo, and select &amp;ldquo;Setup Build&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-eu-west-1.amazonaws.com/aksidjenakfjg/github-vsts-yaml/setup-build.png&#34; alt=&#34;Building code from an external repo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In the next screen, we specify that we are building a project from GitHub, and paste in the access token we created earlier.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-eu-west-1.amazonaws.com/aksidjenakfjg/github-vsts-yaml/entering-the-access-token.png&#34; alt=&#34;entering the personal access token&#34; /&gt;.&lt;/p&gt;

&lt;p&gt;Finally, we are presented with a list of all the repos our account has access to. We need to find our clone of &lt;code&gt;sql-server-samples&lt;/code&gt; in this list and select it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-eu-west-1.amazonaws.com/aksidjenakfjg/github-vsts-yaml/select-repo.png&#34; alt=&#34;selecting the repo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re presented with a list of build process templates, the one we want is &amp;ldquo;YAML&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-eu-west-1.amazonaws.com/aksidjenakfjg/github-vsts-yaml/select-yaml-build.png&#34; alt=&#34;selecting YAML build&#34; /&gt;.&lt;/p&gt;

&lt;p&gt;All that&amp;rsquo;s left to do is specify the path to our YAML build definition, in this case &lt;code&gt;.vsts-ci-yml&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-eu-west-1.amazonaws.com/aksidjenakfjg/github-vsts-yaml/specify-path-to-yaml-file.png&#34; alt=&#34;specifying the path to the yaml file&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Having got this far, we can go ahead and select &amp;ldquo;Save and Queue&amp;rdquo;, and a new build will be created using the &amp;ldquo;Hello World&amp;rdquo; build definition we created earlier.&lt;/p&gt;

&lt;p&gt;If we look at the output of our build, we can see our text being written to the log.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-eu-west-1.amazonaws.com/aksidjenakfjg/github-vsts-yaml/successful-build.png&#34; alt=&#34;building the trivial project&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Almost all of the elapsed time here was cloning the repo from GitHub, there is quite a lot of stuff in it!&lt;/p&gt;

&lt;h2 id=&#34;building-the-real-project&#34;&gt;Building the real project&lt;/h2&gt;

&lt;p&gt;This is all very well, but we haven&amp;rsquo;t managed to build our actual database project yet. To do so, we&amp;rsquo;ll need to go back to GitHub and edit the build definition file.&lt;/p&gt;

&lt;p&gt;The documentation for how to specify build steps in YAML is still a &amp;ldquo;work in progress&amp;rdquo;. In summary, the current procedure is to visit the &lt;a href=&#34;https://github.com/Microsoft/vsts-tasks/tree/master/Tasks&#34;&gt;VSTS Tasks repo on GitHub&lt;/a&gt;, open the folder for the task your are interested in, and take a look at the &lt;code&gt;task.json&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In our case, the first task we need is &lt;a href=&#34;https://github.com/Microsoft/vsts-tasks/tree/master/Tasks/MSBuild&#34;&gt;MSBuild&lt;/a&gt;, to build the database project. Looking inside &lt;a href=&#34;https://github.com/Microsoft/vsts-tasks/blob/master/Tasks/MSBuild/task.json&#34;&gt;task.json&lt;/a&gt;, we can see that the name of the task we need is &lt;code&gt;MSBuild&lt;/code&gt;, and that there are a huge number of available &lt;code&gt;inputs&lt;/code&gt; we can use to configure the task; &lt;code&gt;solution&lt;/code&gt; to specify the project or solution to build, &lt;code&gt;platform&lt;/code&gt;, &lt;code&gt;configuration&lt;/code&gt;, and many more. In our case, we&amp;rsquo;ll just specify the path to our &lt;code&gt;.sqlproj&lt;/code&gt; file and let &lt;code&gt;msbuild&lt;/code&gt; take care of the rest.&lt;/p&gt;

&lt;p&gt;Having built the project, we need to copy our output somewhere so we can use it later. In this case, we&amp;rsquo;ll use the &amp;ldquo;Publish Build Artifacts&amp;rdquo; task to copy the built dacpac file to VSTS.&lt;/p&gt;

&lt;p&gt;The complete build definition is shown below. We build the database project with MSBuild, then specify the path to the built artifact to copy. The artifact itself needs a name, so we can reference it later, for instance in a Release Definition, as well as a type. &lt;code&gt;ArtifactType: Container&lt;/code&gt; just means that we are storing the artifact in VSTS, rather than in an external file share, for example.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;steps&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;-&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;task&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;MSBuild@&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;displayName&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;Build&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;the&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;database&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;project&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;inputs&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;solution&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;samples/databases/wide-world-importers/wwi-ssdt/wwi-ssdt/WideWorldImporters.sqlproj&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;-&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;task&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;PublishBuildArtifacts@&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;inputs&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;PathtoPublish&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;samples/databases/wide-world-importers/wwi-ssdt/wwi-ssdt/bin/Debug/WideWorldImporters.dacpac&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;ArtifactName&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;theDacpac&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;ArtifactType&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;Container&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you take a glance at the history of this file, you&amp;rsquo;ll observe it took me a couple of attempts to get this working; the single quotes turned out to be more important than I originally anticipated. Having overcome that hurdle, we can see that the build succeeds, and produces a single artifact containing our &lt;code&gt;dacpac&lt;/code&gt; file.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-eu-west-1.amazonaws.com/aksidjenakfjg/github-vsts-yaml/build-succeeded.png&#34; alt=&#34;build succeeded and produced an artifact&#34; /&gt;&lt;/p&gt;

&lt;p&gt;For now, this is where the story ends for YAML builds in VSTS, I&amp;rsquo;ll try to return to this topic later once YAML release management is publically available.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Note that contrary to the current version of the docs, &amp;ldquo;Build YAML Definitions&amp;rdquo; is an account-scoped feature rather than a user-scoped feature, so if you&amp;rsquo;re following along at work this will enable it for every user in your VSTS Account.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Expose VSTS secrets as environment variables with this one weird trick...</title>
          <link>http://arapaima.uk/post/2017-10-23-vsts-secret-environment-variables/</link>
          <pubDate>Mon, 23 Oct 2017 00:00:00 UTC</pubDate>
          <author>Gavin Campbell</author>
          <guid>http://arapaima.uk/post/2017-10-23-vsts-secret-environment-variables/</guid>
          <description>

&lt;h2 id=&#34;config-as-environment-variables&#34;&gt;Config as environment variables&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;m a big fan of the &lt;a href=&#34;https://12factor.net/&#34;&gt;Twelve-Factor App&lt;/a&gt; &amp;ldquo;methodology&amp;rdquo;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; for building and deploying applications, and whilst much of it is geared towards web apps in Heroku-esque environments, I think the principles - or &amp;ldquo;factors&amp;rdquo; - are well worth bearing in mind when considering the delivery of other types of application.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://12factor.net/config&#34;&gt;Factor 3 of the 12&lt;/a&gt; reads as follows&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;An app’s config is everything that is likely to vary between deploys (staging, production, developer environments, etc). This includes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Resource handles to the database, Memcached, and other backing services&lt;/li&gt;
&lt;li&gt;Credentials to external services such as Amazon S3 or Twitter&lt;/li&gt;
&lt;li&gt;Per-deploy values such as the canonical hostname for the deploy&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;There are a number of benefits to this approach, the main ones I can think of are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The obvious one about not having credentials stored in source control. Nobody does this anymore, right?&lt;/li&gt;
&lt;li&gt;If environment specific information such as server names are stored with the source control, then changes in the infrastructure will result in new commits in the source repo, meaning that the commit history will no longer merely &amp;ldquo;tell the story&amp;rdquo; of the application, but will also contain numerous sub-plots regarding the infrastructure.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;the-downside&#34;&gt;The downside&lt;/h3&gt;

&lt;p&gt;There is some debate over whether environment variables are really the best place for secret information, and there are definitely customers for whom this approach would be considered too high risk. However, I wouldn&amp;rsquo;t have thought these included the customers where the credentials are currently stored with the application source code!&lt;/p&gt;

&lt;p&gt;The main alternatives generally revolve around storing credentials somewhere where the infrastructure automation tools - Ansible, etc. - can see them and using these tools to deploy a file which the applications can read.&lt;/p&gt;

&lt;h2 id=&#34;never-mind-the-downside-on-with-the-weird-trick&#34;&gt;Never mind the downside, on with the weird trick&amp;hellip;&lt;/h2&gt;

&lt;p&gt;I used the following example of the &amp;ldquo;config as environment variables&amp;rdquo; approach in a recent talk about SSDT and VSTS, using a Powershell Script to read config values from environment variables and deploy a dacpac to a SQL Azure database using SQL Authentication.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Powershell&#34; data-lang=&#34;Powershell&#34;&gt;$serverName=$env:Chinook_ServerName
$dbName = $env:Chinook_DatabaseName
$dbUser = $env:Chinook_DbUser
$dbPassword = $env:Chinook_DbPassword

$dacFxDll=&amp;#39;C:\Program Files (x86)\Microsoft SQL Server\140\DAC\bin\Microsoft.SqlServer.Dac.dll&amp;#39;

Add-Type -Path $dacFxDll
$dacServices = New-Object Microsoft.SqlServer.Dac.DacServices &amp;#34;server=$serverName;User ID=$dbUser;Password=$dbPassword;&amp;#34;

$dacpacPath=Join-Path -Path $PSScriptRoot -ChildPath &amp;#34;\bin\Debug\ChinookDb.dacpac&amp;#34;
$publishProfilePath = Join-Path -Path $PSScriptRoot -ChildPath &amp;#34;CommonSettings.publish.xml&amp;#34;

$dacpac = [Microsoft.SqlServer.Dac.DacPackage]::Load($dacpacPath)
$dacProfile = [Microsoft.SqlServer.Dac.DacProfile]::Load($publishProfilePath)

$dacServices.Deploy($dacpac, $dbName, $true, $dacProfile.DeployOptions )&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What this script does, in brief, is load the server name, database name, and credentials from environment variables, and then deploy a &lt;code&gt;.dacpac&lt;/code&gt; using this information in addition to a publish profile(&lt;code&gt;CommonSettings.publish.xml&lt;/code&gt;) that defines some common - to &lt;em&gt;all&lt;/em&gt; environments - deployment configuration.&lt;/p&gt;

&lt;p&gt;The main advantage of this approach is that the &lt;em&gt;same&lt;/em&gt; deployment script can be used without modification in &lt;em&gt;all&lt;/em&gt; environments, from the developer&amp;rsquo;s desktop through the various testing environments and on to UAT and Production.&lt;/p&gt;

&lt;p&gt;So, for deployments from the desktop or other unmanaged environments, it is easy to specify these values by setting environment variables.&lt;/p&gt;

&lt;p&gt;However, in VSTS, things are a little more complicated. It&amp;rsquo;s possible to use &lt;a href=&#34;https://docs.microsoft.com/en-us/vsts/build-release/concepts/agents/pools-queues#creating-agent-pools-and-queues&#34;&gt;private agent queues&lt;/a&gt; to allocate specific build agents - which could have these variables set in advance -  to specific environments, but what if we just want to use the &lt;a href=&#34;https://docs.microsoft.com/en-us/vsts/build-release/concepts/agents/hosted#use-a-hosted-agent&#34;&gt;hosted queue&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/vsts/build-release/concepts/releases/&#34;&gt;VSTS Release Management&lt;/a&gt; allows us to specify variables for each environment in our &lt;a href=&#34;https://docs.microsoft.com/en-us/vsts/build-release/concepts/definitions/release/&#34;&gt;Release Definition&lt;/a&gt;. It&amp;rsquo;s fairly common to see these used as parameters to deployment tasks, but what is possibly less obvious from this interface is that these values are surfaced as &lt;em&gt;environment variables&lt;/em&gt; in the build process.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-eu-west-1.amazonaws.com/aksidjenakfjg/vsts-secret-vars/variablesinreleasedefinition.png&#34; alt=&#34;Variables pane in VSTS Release Management&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This means that our Powershell script above can still work unmodified - except, that is, for the password. This is masked in the screenshot  as it is defined as a &amp;ldquo;secret&amp;rdquo; variable. Secret variables are &lt;a href=&#34;https://docs.microsoft.com/en-us/vsts/build-release/concepts/definitions/build/variables?tabs=batch#secret-variables&#34;&gt;not exposed as environment variables&lt;/a&gt;, but can only be passed as arguments to our build steps. What muddies the water slightly is that within living memory &lt;a href=&#34;https://github.com/Microsoft/vsts-agent/issues/145&#34;&gt;secret variables &lt;em&gt;were&lt;/em&gt; exposed as environment variables&lt;/a&gt;, but this behaviour was &amp;ldquo;fixed&amp;rdquo; some time in 2016.&lt;/p&gt;

&lt;h3 id=&#34;finally-the-weird-trick&#34;&gt;Finally, the weird trick&lt;/h3&gt;

&lt;p&gt;In the above example, there is an empty environment variable &lt;code&gt;Chinook_DbPassword&lt;/code&gt; for each environment, and a corresponding &lt;em&gt;secret&lt;/em&gt; variable that contains the actual password.&lt;/p&gt;

&lt;p&gt;We need to add an additional task to our release definition to read the secret variable and surface it as an environment variable. This can be done through the &lt;a href=&#34;https://github.com/Microsoft/vsts-tasks/blob/master/docs/authoring/commands.md&#34;&gt;VSTS logging commands&lt;/a&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;, which are worth checking out as they enable a number of &amp;ldquo;weird tricks&amp;rdquo; in addition to this particular one.&lt;/p&gt;

&lt;p&gt;As per the documentation, Logging Commands are invoked by writing the command to standard output, which in the case of PowerShell is done via &lt;code&gt;Write-Host&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-eu-west-1.amazonaws.com/aksidjenakfjg/vsts-secret-vars/PowerShellStepToReadSecretVariable.png&#34; alt=&#34;Release Definition showing PowerShell step to decrypt secret variable&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In accordance with the &amp;ldquo;rules&amp;rdquo;, we pass the secret variable as an argument to the script, then use the &lt;code&gt;##vso[task.setvariable]&lt;/code&gt; command to set the value of the non-secret environment variable to the value of the argument.&lt;/p&gt;

&lt;p&gt;In the logs for the release, we can see the non-secret variables being set, with &lt;code&gt;Chinook_dbPassword&lt;/code&gt; set to blank (&lt;code&gt;[]&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2017-10-13T12:00:12.1607197Z Environment variables available are below.  
...
...
    [AGENT_HOMEDIRECTORY] --&amp;gt; [C:\LR\mms\Services\Mms\Provisioner\TaskAgent\agents\2.123.0]
...    
...
    [CHINOOK_DATABASENAME] --&amp;gt; [Chinook]
    [CHINOOK_DBPASSWORD] --&amp;gt; []
    [CHINOOK_DBUSER] --&amp;gt; [arapaima]
    [CHINOOK_SERVERNAME] --&amp;gt; [vstsdemochinook.database.windows.net]
...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we get to the logs for the &amp;ldquo;Read Env Var&amp;rdquo; step:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2017-10-13T12:00:14.5784670Z ##[section]Starting: Read Env Var
2017-10-13T12:00:14.5954676Z ==============================================================================
2017-10-13T12:00:14.5954676Z Task         : PowerShell
2017-10-13T12:00:14.5954676Z Description  : Run a PowerShell script
2017-10-13T12:00:14.5954676Z Version      : 1.2.3
2017-10-13T12:00:14.5954676Z Author       : Microsoft Corporation
2017-10-13T12:00:14.5954676Z Help         : [More Information]
2017-10-13T12:00:14.5954676Z ==============================================================================
2017-10-13T12:00:14.6704451Z ##[command]. &#39;d:\a\_temp\2fa5955a-1363-464a-bed7-aed0cbea2c96.ps1&#39; ********
2017-10-13T12:00:15.5054467Z ##[section]Finishing: Read Env Var
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we can see that the secret variable is passed as a parameter to the inline script, but masked with asterisks in the release logs.&lt;/p&gt;

&lt;p&gt;The &amp;ldquo;Deploy Dacpac&amp;rdquo; step contains a single action, namely running the same Powershell script as was used in every other environment:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2017-10-13T12:01:30.0026563Z ##[section]Starting: Deploy Dacpac
2017-10-13T12:01:30.0036563Z ==============================================================================
2017-10-13T12:01:30.0036563Z Task         : PowerShell
2017-10-13T12:01:30.0036563Z Description  : Run a PowerShell script
2017-10-13T12:01:30.0036563Z Version      : 1.2.3
2017-10-13T12:01:30.0036563Z Author       : Microsoft Corporation
2017-10-13T12:01:30.0036563Z Help         : [More Information]
2017-10-13T12:01:30.0036563Z ==============================================================================
2017-10-13T12:01:30.0076572Z ##[command]. &#39;d:\a\r1\a\ChinookDb-CI\BuildOutput\Deploy.ps1&#39; 
2017-10-13T12:02:10.3410313Z ##[section]Finishing: Deploy Dacpac
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This isn&amp;rsquo;t restricted to Release Definitions, the same technique will work in Build Definitions too. This is possibly a less common scenario - as &lt;em&gt;builds&lt;/em&gt; shouldn&amp;rsquo;t normally contain environment-specific information - except in cases like database deployment where it&amp;rsquo;s generally necessary to deploy the database &lt;a href=&#34;https://stackoverflow.com/questions/39443317/can-you-run-sql-unit-tests-tsqlt-during-build-process-in-vsts&#34;&gt;&lt;em&gt;somewhere&lt;/em&gt;&lt;/a&gt; before we can do any automated testing.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Their words, not mine!
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;I can&amp;rsquo;t find this page on docs.microsoft.com, so the link is to the &lt;a href=&#34;https://github.com/Microsoft/vsts-tasks/blob/master/docs/authoring/commands.md&#34;&gt;Github source&lt;/a&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Automatically provisioning a brand new environment for every feature branch using VSTS and AzureRM</title>
          <link>http://arapaima.uk/post/2017-09-07-vsts-azurerm-dynamic-environment-provisioning/</link>
          <pubDate>Thu, 07 Sep 2017 00:00:00 UTC</pubDate>
          <author>Gavin Campbell</author>
          <guid>http://arapaima.uk/post/2017-09-07-vsts-azurerm-dynamic-environment-provisioning/</guid>
          <description>

&lt;p&gt;It&amp;rsquo;s fairly uncontentious to suggest that, all else being equal, providing each developer with an individual &amp;ldquo;sandbox&amp;rdquo;, or private development environment, is a &lt;a href=&#34;http://www.agiledata.org/essays/sandboxes.html&#34;&gt;worthwhile endeavour&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Often, these can be provisioned on the developers individual desktops, but when the application involves PaaS services such as databases, message queues, and other cloud-based services, things become more complicated. It&amp;rsquo;s generally possible to emulate &lt;em&gt;most&lt;/em&gt; things on the desktop, but there are often small gaps in this emulation, not least in the communication and authentication protocols that link the services together.&lt;/p&gt;

&lt;p&gt;The rest of this article will discuss how to use &lt;a href=&#34;https://www.visualstudio.com/team-services/&#34;&gt;Visual Studio Team Services&lt;/a&gt; in conjunction with &lt;a href=&#34;https://azure.microsoft.com/en-gb/features/resource-manager/&#34;&gt;Azure Resource Manger&lt;/a&gt; (henceforward AzureRM) templates to automatically provision a new environment for every branch created in source control, and automatically destroy the environment using a service hook to &lt;a href=&#34;https://azure.microsoft.com/en-gb/services/automation/&#34;&gt;Azure Automation&lt;/a&gt; when the branch is merged to master and deleted.&lt;/p&gt;

&lt;p&gt;I stumbled on this technique whilst working on a proof of concept involving the data-related Azure services, such as Data Factory, Data Lake, and Azure SQL Data Warehouse, but the present example consists of a serverless &lt;a href=&#34;https://azure.microsoft.com/en-gb/services/functions/&#34;&gt;Azure Function&lt;/a&gt; that writes to a &lt;a href=&#34;https://azure.microsoft.com/en-gb/services/cosmos-db/&#34;&gt;Cosmos DB&lt;/a&gt; PaaS Database.&lt;/p&gt;

&lt;p&gt;This technique should generalise to most Azure PaaS services, and yes, I&amp;rsquo;m sure you can do similar things with AWS and friends but I haven&amp;rsquo;t had cause to think about them for the time being.&lt;/p&gt;

&lt;h3 id=&#34;the-application-code&#34;&gt;The application code&lt;/h3&gt;

&lt;p&gt;The project I&amp;rsquo;m using for this example can be downloaded from &lt;a href=&#34;https://github.com/arapaima-uk/KebabAzureRmDemo&#34;&gt;this Github repo&lt;/a&gt;. The Github version of the code is mirrored from the version in VSTS using the &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=nkdagility.gittasks&#34;&gt;Git Tasks&lt;/a&gt; extension for VSTS&lt;/p&gt;

&lt;p&gt;The repo contains a Visual Studio (2017) solution with four projects:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;FavouriteKebab - this is the Azure Function App&lt;/li&gt;
&lt;li&gt;KebabDbResourceGroup - this is the AzureRM template that defines our infrastructure&lt;/li&gt;
&lt;li&gt;KebabTests - contains a single test written with the MSTest framework&lt;/li&gt;
&lt;li&gt;HelperScripts - a Powershell Script project containing a single script used in the build pipeline&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-eu-west-1.amazonaws.com/aksidjenakfjg/vsts-azurerm/solutionexplorerview.PNG&#34; alt=&#34;Solution Explorer View&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;the-next-instagram&#34;&gt;The next Instagram?&lt;/h3&gt;

&lt;p&gt;The details of what the app actually &lt;em&gt;does&lt;/em&gt; aren&amp;rsquo;t particularly important for this example, but in brief it is expecting a JSON structure:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;nt&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Bill&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;span class=&#34;nt&#34;&gt;&amp;#34;favouriteKebab&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Adana&amp;#34;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;in the body of a &lt;code&gt;POST&lt;/code&gt; message, which it will then store in the Cosmos DB database.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span class=&#34;na&#34;&gt;[FunctionName(&amp;#34;KebabPost&amp;#34;)]&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;HttpResponseMessage&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Run&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;[HttpTrigger(AuthorizationLevel.Anonymous, &amp;#34;post&amp;#34;)]&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;HttpRequestMessage&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;[DocumentDB(&amp;#34;kebabDb&amp;#34;, &amp;#34;kebabPreferences&amp;#34;,
&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;ConnectionStringSetting = &amp;#34;DB_CONNECTION&amp;#34;, CreateIfNotExists =true)]&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;out&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;dynamic&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nameAndKebabType&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
    &lt;span class=&#34;n&#34;&gt;TraceWriter&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Info&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;C# HTTP trigger function processed a request.&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// Get request body
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;dynamic&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Content&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ReadAsAsync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;().&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// Set name to query string or body data
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;nameAndKebabType&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;?.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;favouriteKebab&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;?.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;favouriteKebab&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;?.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;null&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;?.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;favouriteKebab&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CreateResponse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HttpStatusCode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BadRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
            &lt;span class=&#34;s&#34;&gt;&amp;#34;Name and kebab are both required!&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CreateResponse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HttpStatusCode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;OK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The name of the DocumentDB database and collection will be the same in every environment, so I&amp;rsquo;ve just hardcoded them in the file (&lt;code&gt;&amp;quot;kebabDB&amp;quot;&lt;/code&gt; and &lt;code&gt;&amp;quot;kebabPreferences&amp;quot;&lt;/code&gt;). The other thing to note is that I am passing &lt;code&gt;CreateIfNotExists=true&lt;/code&gt; in the binding options for the DocumentDB collection; it turns out to be non-trivial to create the database and the collection from an AzureRM template, so we let the app create them at runtime if required.&lt;/p&gt;

&lt;p&gt;The test project contains a single test, which exercises the behaviour described above:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span class=&#34;na&#34;&gt;[TestMethod]&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;KebabPost_ValidInput_StoresValuesInDb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;content&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;{ &amp;#39;name&amp;#39;:&amp;#39;Barry&amp;#39; , &amp;#39;favouriteKebab&amp;#39;:&amp;#39;Kofte&amp;#39; }&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;client&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;HttpClient&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;response&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PostAsync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;functionUrl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;StringContent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;content&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Encoding&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;UTF8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;application/json&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)).&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;client&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DocumentClient&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;docDbUri&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;docDbKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;IQueryable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;KebabPrefs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kebabPrefsQuery&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;client&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CreateDocumentQuery&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;KebabPrefs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;(&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;UriFactory&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CreateDocumentCollectionUri&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;kebabDb&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;kebabPreferences&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Where&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;kp&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Barry&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;Assert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;AreEqual&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Kofte&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kebabPrefsQuery&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ToList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;First&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;favouriteKebab&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;


    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Unit Testing enthusiasts will have noticed that this isn&amp;rsquo;t really a Unit Test at all; there are no fakes or mocks, we are using the &amp;ldquo;real&amp;rdquo; dependencies for everything.&lt;/p&gt;

&lt;p&gt;If our Azure function were a bit bigger, it would be worth splitting out the &amp;ldquo;core&amp;rdquo; functionality into a separate assembly that &lt;em&gt;could&lt;/em&gt; be meaningfully unit tested, but in the interests of brevity I&amp;rsquo;ve not done that here.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Integration&lt;/em&gt; tests of this kind are pretty common in PaaS projects, and a glance at the &lt;a href=&#34;https://github.com/arapaima-uk/KebabAzureRmDemo/blob/master/KebabTests/KebabTests.cs&#34;&gt;full source code of the test project &lt;/a&gt; will reveal many of the common &amp;ldquo;characteristics&amp;rdquo; of coded integration tests; acres of boilerplate code to read config files and set up the initial conditions, POCOs not present in the main application whose only purpose is to hold data for our test, etc. etc. Still, all of this fragility and maintenance difficulty is probably a price worth paying for increased confidence in our deployment pipeline.&lt;/p&gt;

&lt;h2 id=&#34;the-azurerm-template&#34;&gt;The AzureRM Template&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/arapaima-uk/KebabAzureRmDemo/blob/master/KebabDbResourceGroup/azuredeploy.json&#34;&gt;full template&lt;/a&gt; is a bit too long to reproduce here, so I&amp;rsquo;ll call out some edited highlights.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;  &lt;span class=&#34;s2&#34;&gt;&amp;#34;parameters&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;database_account_name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;nt&#34;&gt;&amp;#34;defaultValue&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;[concat(&amp;#39;kebabdac&amp;#39;, uniqueString(resourceGroup().id))]&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
      &lt;span class=&#34;nt&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;hostingPlanName&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;nt&#34;&gt;&amp;#34;defaultValue&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;[concat(&amp;#39;kebabhp&amp;#39;, uniqueString(resourceGroup().id))]&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
      &lt;span class=&#34;nt&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;functionAppName&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;nt&#34;&gt;&amp;#34;defaultValue&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;[concat(&amp;#39;kebabApp&amp;#39;, uniqueString(resourceGroup().id))]&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
      &lt;span class=&#34;nt&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;storageAccountName&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;nt&#34;&gt;&amp;#34;defaultValue&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;[concat(&amp;#39;kebabstor&amp;#39;, uniqueString(resourceGroup().id))]&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
      &lt;span class=&#34;nt&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The thing to note is that the template takes four parameters, each of which has a default value.&lt;/p&gt;

&lt;p&gt;Each of the defaults consists of a prefix that identifies the resource type, combined with the result of the function &lt;code&gt;uniqueString(resourceGroup().id)&lt;/code&gt;. These unique strings are required as there are some objects in Azure (storage accounts or web apps for example) that require &lt;em&gt;globally&lt;/em&gt; unique names that can be incorporated into a url of the form &lt;code&gt;https://myapp.azurewebsites.net&lt;/code&gt; or similar. I can never remember which objects do require unique names and which ones don&amp;rsquo;t, so I tend to use &lt;code&gt;uniqueString()&lt;/code&gt; for everything.&lt;/p&gt;

&lt;p&gt;The template goes on to create a storage account, a Cosmos DB account, a Function App, and all the supporting bits these require. These end up with some pretty funky names thanks to the use of &lt;code&gt;uniqueString()&lt;/code&gt;, but since you never really need to type these names anywhere this is more of an aesthetic consideration than a practical problem:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-eu-west-1.amazonaws.com/aksidjenakfjg/vsts-azurerm/resources.png&#34; alt=&#34;Azure resource names generated with uniqueString&#34; /&gt;&lt;/p&gt;

&lt;p&gt;At the end of the template is an &lt;code&gt;outputs&lt;/code&gt; section:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;  &lt;span class=&#34;s2&#34;&gt;&amp;#34;outputs&amp;#34;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;functionAppName&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;nt&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
      &lt;span class=&#34;nt&#34;&gt;&amp;#34;value&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;[parameters(&amp;#39;functionAppName&amp;#39;)]&amp;#34;&lt;/span&gt;

    &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;docDbUri&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;nt&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
      &lt;span class=&#34;nt&#34;&gt;&amp;#34;value&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;[Concat(&amp;#39;https://&amp;#39;,parameters(&amp;#39;database_account_name&amp;#39;),&amp;#39;.documents.azure.com:443&amp;#39;)]&amp;#34;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;docDbKey&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;nt&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
      &lt;span class=&#34;nt&#34;&gt;&amp;#34;value&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;[listKeys(resourceId(&amp;#39;Microsoft.DocumentDb/databaseAccounts&amp;#39;, parameters(&amp;#39;database_account_name&amp;#39;)), &amp;#39;2015-04-08&amp;#39;).primaryMasterKey]&amp;#34;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This defines three outputs, the Function App name, the Cosmos DB uri, and the Cosmos DB key. This is necessary as we didn&amp;rsquo;t specify these values ourselves, so we need AzureRM to &lt;em&gt;tell us what it just created&lt;/em&gt; in order that we can use these names for other tasks in our build process.&lt;/p&gt;

&lt;h3 id=&#34;the-build-definition&#34;&gt;The Build Definition&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-eu-west-1.amazonaws.com/aksidjenakfjg/vsts-azurerm/builddefinition.png&#34; alt=&#34;The Build Steps in VSTS&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This is a fairly standard workflow, with a couple of things of note. We build the solution at the beginning and save the artifacts, but before we run our integration test(s?), we run the AzureRM template to &amp;ldquo;Create or Update&amp;rdquo; a resource group, and then deploy our Function App inside this resource group. This is so that we can run our integration tests with the real dependencies. The &amp;ldquo;trick&amp;rdquo;, such as it is, is in the AzureRM deployment step:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-eu-west-1.amazonaws.com/aksidjenakfjg/vsts-azurerm/AzureRMStep.png&#34; alt=&#34;AzureRM Deploy step showing parameters&#34; /&gt;.&lt;/p&gt;

&lt;p&gt;By passing the &lt;em&gt;name of the branch we are building&lt;/em&gt; as the name of the resource group, this means that the first time we build any given branch we will get a brand new environment with a Cosmos DB, a Function App, etc. etc., exclusively for that build.&lt;/p&gt;

&lt;p&gt;After the template is deployed, we need a bit of Powershell to retrieve the outputs from the template.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-powershell&#34; data-lang=&#34;powershell&#34;&gt;&lt;span class=&#34;k&#34;&gt;param&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;no&#34;&gt;[string]&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$resourceGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;nv&#34;&gt;$outputs&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;Get-AzureRmResourceGroupDeployment&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;-ResourceGroupName&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$resourceGroup&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Sort&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Timestamp&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;-Descending&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Select&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;-First&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Outputs&lt;/span&gt;

&lt;span class=&#34;nv&#34;&gt;$outputs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Keys&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;Write-Host&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;##vso[task.setvariable variable=&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;;]&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$outputs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What this does is to find the most recent deployment for the specified resource group - i.e. the one we just did - and map the &lt;em&gt;outputs&lt;/em&gt; of the template to &lt;em&gt;build variables&lt;/em&gt; in VSTS by name. This means that for every output in the template, we need to define a build variable with &lt;em&gt;exactly&lt;/em&gt; the same name, which indeed we have done:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-eu-west-1.amazonaws.com/aksidjenakfjg/vsts-azurerm/buildvars.png&#34; alt=&#34;Build variables view&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The values are all empty, as they will be assigned by the above script during each build.&lt;/p&gt;

&lt;p&gt;We can then use these variables in the Function App deployment step to tell it where to deploy our Function:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-eu-west-1.amazonaws.com/aksidjenakfjg/vsts-azurerm/appServiceDeploy.png&#34; alt=&#34;FunctionAppDeployment&#34; /&gt;&lt;/p&gt;

&lt;p&gt;as well as in the Integration Testing step, where we use these variables to overwrite the values in the &lt;code&gt;runsettings&lt;/code&gt; file used by the &lt;code&gt;vstest&lt;/code&gt; test runner.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-eu-west-1.amazonaws.com/aksidjenakfjg/vsts-azurerm/runsettings.png&#34; alt=&#34;runsettings&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The final step is just to update the Github mirror of the VSTS repo; in most corporate environments this won&amp;rsquo;t be necessary!&lt;/p&gt;

&lt;h3 id=&#34;the-build-trigger&#34;&gt;The Build Trigger&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-eu-west-1.amazonaws.com/aksidjenakfjg/vsts-azurerm/buildtrigger.png&#34; alt=&#34;https://s3-eu-west-1.amazonaws.com/aksidjenakfjg/vsts-azurerm/buildtrigger.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This build will be run for every new commit on every branch. A moment&amp;rsquo;s reflection will reveal that if the branch is created through the UI on the server, the build will be triggered immediately, as there will be a new branch with a new (to that branch) commit. The first build will always be the slowest, as this is the one that will create the resource group from scratch.&lt;/p&gt;

&lt;p&gt;Equally, a new build will be triggered every time the developer pushes new commits to the feature branch, following which the artifacts will be deployed and the integration tests run, &lt;em&gt;in the private environment dedicated to that branch&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Subsequent builds will be faster; the time penalty associated with creating the resource group from scratch is around two minutes in this particular case, using the hosted queue (2:32 to create from scratch, 0:38 to revalidate on subsequent builds). The overall build time is around 5 minutes the first time, and 3 minutes on subsequent runs. (since there&amp;rsquo;s only one integration test, the slowest part is the nuget restore!).&lt;/p&gt;

&lt;h3 id=&#34;branch-policy&#34;&gt;Branch Policy&lt;/h3&gt;

&lt;p&gt;In addition to enforcing a build on every commit, we can force another build at the point a pull request is made from our feature branch to master:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-eu-west-1.amazonaws.com/aksidjenakfjg/vsts-azurerm/masterbranchpolicy.png&#34; alt=&#34;Master branch policy in vsts&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This will &amp;ldquo;pre-merge&amp;rdquo; our feature branch into master, and trigger a new build. This will have the side effect of creating a new resource group called &amp;ldquo;merge&amp;rdquo;, in which the tests will be run again. However, since the same branch name is used for every pull-request build, the &amp;ldquo;merge&amp;rdquo; resource group will only be created once, and won&amp;rsquo;t be modified unless the AzureRM template changes.&lt;/p&gt;

&lt;h3 id=&#34;merging-a-pull-request&#34;&gt;Merging a Pull Request&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-eu-west-1.amazonaws.com/aksidjenakfjg/vsts-azurerm/closingapr.png&#34; alt=&#34;Merging a PR&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This screenshot shows the &amp;ldquo;moment of truth&amp;rdquo; immediately prior to merging a pull request. The &amp;ldquo;pre-merged&amp;rdquo; branch has been built successfully, and when we click &amp;ldquo;Complete Merge&amp;rdquo; the source branch will be deleted. The resource group, however, will still be hanging around incurring charges, and this could become an expensive business if we are creating a new environment for every single feature and never tearing them down.&lt;/p&gt;

&lt;h3 id=&#34;tearing-down-the-environment&#34;&gt;Tearing down the environment&lt;/h3&gt;

&lt;p&gt;This is achieved by calling an Azure Automation runbook in a Service Hook from VSTS.&lt;/p&gt;

&lt;p&gt;To create the hook, we first need to define our Automation runbook and give it a web endpoint. The integration of Azure Automation and source control is a &amp;ldquo;work in progress&amp;rdquo;, so I&amp;rsquo;ve stored the body of the runbook in a gist&lt;/p&gt;

&lt;p&gt;&lt;script src=&#34;//gist.github.com/gavincampbell/a12a87477bd38402b310262040509a56.js&#34;&gt;&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;This script will parse the JSON payload from VSTS, find the source branch name (from the refspec), and delete the resource group with that name. This runbook is associated with an endpoint url, which we provide to VSTS in the Web hook configuration.&lt;/p&gt;

&lt;p&gt;The runbook requires an Azure Automation Account.  I have created these in a separate resource group, not &amp;ldquo;managed&amp;rdquo; from VSTS.&lt;/p&gt;

&lt;p&gt;We set the event to track to &amp;ldquo;Pull request merge commit created&amp;rdquo; - there&amp;rsquo;s no &amp;ldquo;branch deleted&amp;rdquo; event available here. Remember, the branch gets deleted when the PR is merged, assuming the box is ticked. Notably, we are only firing this event on merges &lt;em&gt;to&lt;/em&gt; master.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-eu-west-1.amazonaws.com/aksidjenakfjg/vsts-azurerm/servicehookp1.png&#34; alt=&#34;Service Hook p1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;On the second page of the dialog, we just supply the endpoint url for our Automation runbook.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-eu-west-1.amazonaws.com/aksidjenakfjg/vsts-azurerm/servicehookp2.png&#34; alt=&#34;Service Hook p2&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;release-management&#34;&gt;Release Management&lt;/h2&gt;

&lt;p&gt;Once the branch is merged to master and its environment torn down, then what? We release the feature, of course:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-eu-west-1.amazonaws.com/aksidjenakfjg/vsts-azurerm/releaseprocess.png&#34; alt=&#34;Release Management in VSTS&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This Release definition is triggered on every new build of the master branch. Since the branch is protected by a policy, these will only occur when a pull request has been created, successfully built, reviewed, and merged.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-eu-west-1.amazonaws.com/aksidjenakfjg/vsts-azurerm/releasetrigger.png&#34; alt=&#34;Release Trigger&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As soon as the release is triggered, we do a deployment to QA. The &amp;ldquo;little man with a clock&amp;rdquo; next to the &amp;ldquo;Production&amp;rdquo; environment indicated that there is a manual approval required before a release can be deployed to production.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-eu-west-1.amazonaws.com/aksidjenakfjg/vsts-azurerm/qatrigger.png&#34; alt=&#34;QA trigger&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;the-deployment-process&#34;&gt;The deployment process&lt;/h3&gt;

&lt;p&gt;As is typical, the Release Definition is much simpler than the Build Definition. In this instance it consists of only two steps, deploying the Azure RM template and deploying the Function to our Function App.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-eu-west-1.amazonaws.com/aksidjenakfjg/vsts-azurerm/deploymenttasks.png&#34; alt=&#34;Release tasks in VSTS&#34; /&gt;&lt;/p&gt;

&lt;p&gt;What&amp;rsquo;s notable though, is that we are using the same Azure RM template for QA and Production as we used for the ephemeral development environments. The only difference is that instead of allowing the parameters to default to their &amp;ldquo;unique string&amp;rdquo; values, we explicitly set all these parameters to &amp;ldquo;well known&amp;rdquo; values in the step definition:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-eu-west-1.amazonaws.com/aksidjenakfjg/vsts-azurerm/overridetemplateparameters.png&#34; alt=&#34;Azure RM Release Step Definition&#34; /&gt;&lt;/p&gt;

&lt;p&gt;as well as in the step that deploys the function to our function app:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-eu-west-1.amazonaws.com/aksidjenakfjg/vsts-azurerm/overrideAppServicename.png&#34; alt=&#34;Azure Function Release Step Definition&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The Production environment definition is exactly the same as the QA one, except that the &amp;ldquo;well known&amp;rdquo; values for the resource names are different.&lt;/p&gt;

&lt;p&gt;This means that it doesn&amp;rsquo;t matter if the QA and Prod environments are maintained by a different team, or if they are created in a different subscription or in a different tenant; as long as we know the values to plug into our template, we can override our defaults with the &amp;ldquo;permanent&amp;rdquo; names.&lt;/p&gt;

&lt;p&gt;The &amp;ldquo;permanent&amp;rdquo; resource names still need to respect the rules for uniqueness though, so if these names are important it is probably wise to create these resources in advance to avoid disappointment at deployment time.&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;If you&amp;rsquo;re still reading, you&amp;rsquo;ll be aware that this has been a somewhat &amp;ldquo;epic&amp;rdquo; article. The scenario outlined above allows us to automatically create and tear down a new environment for every single feature. Under normal circumstances, there will be four &amp;ldquo;persistent&amp;rdquo; resource groups, namely &amp;ldquo;QA&amp;rdquo; and &amp;ldquo;Production&amp;rdquo;, as well as &amp;ldquo;merge&amp;rdquo; - used for building and testing &amp;ldquo;pre-merged&amp;rdquo; pull requests, and &amp;ldquo;master&amp;rdquo; - used to rebuild and retest &amp;ldquo;master&amp;rdquo; after every merge commit.&lt;/p&gt;

&lt;p&gt;The extra resource group for Azure Automation is also visible in this screenshot, as is the resource group for a feature branch, which will be automatically torn down when the branch is merged.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://s3-eu-west-1.amazonaws.com/aksidjenakfjg/vsts-azurerm/ResourceGroups.png&#34; alt=&#34;resource groups in the Azure Portal&#34; /&gt;&lt;/p&gt;

&lt;p&gt;All of the above is still a work in progress, if there are any glaring errors or omissions please do get in touch via the comments or via the &lt;a href=&#34;http://arapaima.uk/fixed/about/&#34;&gt;contact form&lt;/a&gt; on the site.&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
